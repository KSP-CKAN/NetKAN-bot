package App::KSP_CKAN::WebHooks::GenerateReleases;

use v5.010;
use strict;
use warnings;
use autodie;
use Method::Signatures 20140224;
use File::chdir;
use File::Copy qw(copy);
use File::Temp qw(tempdir);
use File::Basename qw(fileparse);
use File::Path qw(remove_tree mkpath);
use File::Copy::Recursive qw(dircopy);
use Scalar::Util 'reftype';
use Try::Tiny;
use App::KSP_CKAN::Tools::Config;
use App::KSP_CKAN::Tools::Git;
use App::KSP_CKAN::Metadata::Releases;
use App::KSP_CKAN::Metadata::Ckan;
use Moo;
use namespace::clean;

# ABSTRACT: CKAN Generate releases on demand

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::WebHooks::GenerateReleases;

  my $generate = App::KSP_CKAN::WebHooks::GenerateReleases->new();
  $generate->releases("/path/to/ckan");

=head1 DESCRIPTION

Webhook wrapper for Generating CKAN-meta releases on demand.

=cut

has 'config'      => ( is => 'ro', lazy => 1, builder => 1 );
has '_CKAN_meta'  => ( is => 'ro', lazy => 1, builder => 1 );
has '_releases'   => ( is => 'ro', lazy => 1, builder => 1 );
has '_working'    => ( is => 'ro', lazy => 1, builder => 1 );

# TODO: This is a hack, the application should be multi
#       function aware.
method _build_config {
  my $working = $ENV{HOME}."/CKAN-Webhooks/releases";
  if ( ! -d $working ) {
    mkpath($working);
  }
  return App::KSP_CKAN::Tools::Config->new(
    working => $working,
  );
}

method _tmp {
  return File::Temp::tempdir();
}

method _build__working {
  return $self->config->working."/".$self->_CKAN_meta->working;
}

method _build__CKAN_meta {
  return App::KSP_CKAN::Tools::Git->new(
    remote  => $self->config->CKAN_meta,
    local   => $self->config->working,
    clean   => 1,
  );
}

method _build__releases {
  return App::KSP_CKAN::Metadata::Releases->new(
    file => $self->_working."/releases.json"
  );
}

method _generate_release($files,$release) {
  my $tmp = $self->_tmp;
  my $ckan = $self->_CKAN_meta;
  my $ckanpath = $self->config->working."/".$ckan->working."/";
  local $CWD = $tmp;
  foreach my $file (@{$files}) {
    my ($name,$path) = fileparse($file);
    my $relative = $path;
    $relative =~ s/$ckanpath//;
    $relative = "." if ! $relative;
    mkpath($relative);
    copy($file, $relative);
  }

  $ckan->orphan_branch($release);
  dircopy($tmp, $ckanpath);

  # If there are no changes, there isn't any work to do
  if (! $ckan->working_status) {
    try {$ckan->pull()}; # Fails if branch doesn't exist upstream
    $ckan->add;
    $ckan->commit( all => 1, message => "Files added to $release" );
    $ckan->push;
  }

  $ckan->checkout_branch("master");
  remove_tree($self->_tmp);
}

=method releases

  $generate->releases( 'relative/CKAN-meta/path/file.ckan' );

Takes a single file (or array of files), with a relative path
within CKAN-meta. It will then find the particular release it
belongs to and pushes it into an orphaned branch named the
same.

For example: Test/Test-1.0.ckan (ksp_version = "1.2")

Would end up in the 'current' branch of CKAN-meta.

=cut

method releases($files) {
  # Lets take an array as well!
  my @files = reftype \$files ne "SCALAR" ? @{$files} : $files;

  # Prepare Enironment
  $self->_CKAN_meta->pull;
  $self->_CKAN_meta->checkout_branch("master");

  my $branches = {};

  foreach my $file (@files) {
    $file = $self->config->working."/CKAN-meta/".$file;
    # Lets not try release non-existent files
    if (! -e $file) {
      $self->warn("The ckan '".$file."' doesn't appear to exist");
      next;
    }

    # Lets only release CKANs
    if (! $file =~ /\.ckan$/) {
      $self->warn("The ckan '".$file."' doesn't appear to be a ckan");
      next;
    }

    my $ckan = App::KSP_CKAN::Metadata::Ckan->new(file => $file);

    my $version = $ckan->ksp_version ? $ckan->ksp_version : $ckan->ksp_version_max;
    if (! defined $version) {
      $version = 'any'
    }

    my $release = $self->_releases->release($version);
    push(@{$branches->{$release}}, $file);
  }

  foreach my $key (keys %$branches) {
    $self->_generate_release($branches->{$key},$key);
  }
  return 1;
}

with('App::KSP_CKAN::Roles::Logger');

1;
