package App::KSP_CKAN::WebHooks::InflateNetKAN;

use v5.010;
use strict;
use warnings;
use autodie;
use Method::Signatures 20140224;
use File::chdir;
use File::Path qw( mkpath );
use Scalar::Util 'reftype';
use App::KSP_CKAN::Tools::Config;
use Moo;
use namespace::clean;

extends 'App::KSP_CKAN::NetKAN';

# ABSTRACT: NetKAN Index on demand

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::WebHooks::InflateNetKAN 'inflate';

  inflate("Netkan.netkan");

=head1 DESCRIPTION

Webhook wrapper for NetKAN inflation on demand.

=cut

has 'config' => ( is => 'ro', lazy => 1, builder => 1 );

# TODO: This is a hack, the application should be multi
#       function aware. 
method _build_config {
  my $working = $ENV{HOME}."/CKAN-Webhooks/inflator";
  if ( ! -d $working ) {
    mkpath($working);
  }
  return App::KSP_CKAN::Tools::Config->new(
    working => $working,
  );
}

method inflate($identifiers) {
  # Lets take an array as well! 
  my @identifiers = reftype \$identifiers ne "SCALAR" ? @{$identifiers} : $identifiers;

  # Prepare Enironment
  $self->_mirror_files;
  $self->_CKAN_meta->pull;
  $self->_NetKAN->pull;
  local $CWD = $self->config->working."/".$self->_NetKAN->working;

  foreach my $identifier (@identifiers) {
    my $file = "NetKAN/".$identifier.".netkan";

    if (! -e $file) {
      $self->warn("The identifier '".$identifier."' doesn't appear to exist");
      next;
    }

    my $netkan = App::KSP_CKAN::Tools::NetKAN->new(
      config      => $self->config,
      file        => $file,
      ckan_meta   => $self->_CKAN_meta,
      status      => $self->_status,
      rescan      => 1,
      overwrite   => 1,
    );
    $netkan->inflate;
  }

  $self->_push;

  # TODO: Status won't be set for inflate on demand because currently
  #       if the a NetKAN is not present in the status object it'll
  #       drop from the JSON output. So for individual inflation we'll
  #       end up with with 1 item in the status.
  return 1;
}

1;
