package App::KSP_CKAN::Metadata::NetKAN;

use v5.010;
use strict;
use warnings;
use autodie;
use Method::Signatures 20140224;
use Config::JSON; # Saves us from file handling
use List::MoreUtils 'any';
use Carp qw( croak );
use Digest::SHA 'sha1_hex';
use URI::Escape 'uri_unescape';
use Scalar::Util 'reftype';
use Moo;
use namespace::clean;

# ABSTRACT: Metadata Wrapper for CKAN files

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Metadata::Ckan;

  my $ckan = App::KSP_CKAN::Metadata::Ckan->new(
    file => "/path/to/file.ckan",
  );

=head1 DESCRIPTION

Provides a ckan metadata object for KSP-CKAN. Has the following
attributes available.

=over

=item identifier

Returns the identifier for the loaded NetKAN.

=item name

Returns the name for the loaded NetKAN.

=item kref

Returns the $kref or undef for the loaded NetKAN.

=item vref

Returns the $vref or undef for the loaded NetKAN.

=item staging

Returns false if not in metadata, else returns the value in the
metadata.

=item license

Returns the license for the loaded NetKAN.

=back

=cut

has 'file'                  => ( is => 'ro', required => 1 ); # TODO: we should do some validation here.
has '_raw'                  => ( is => 'ro', lazy => 1, builder => 1 );
has 'identifier'            => ( is => 'ro', lazy => 1, builder => 1 );
has 'kref'                  => ( is => 'ro', lazy => 1, builder => 1 );
has 'vref'                  => ( is => 'ro', lazy => 1, builder => 1 );
has 'name'                  => ( is => 'ro', lazy => 1, builder => 1 );
has 'staging'               => ( is => 'ro', lazy => 1, builder => 1 );
has 'staging_reason'        => ( is => 'ro', lazy => 1, builder => 1 );
has 'license'               => ( is => 'ro', lazy => 1, builder => 1 );

# TODO: We're already using file slurper + JSON elsewhere. We should
#       pick one method for consistency.
# TODO: This could also barf out on an invalid file, we'll need to
#       Handle that somewhere.
method _build__raw {
  return Config::JSON->new($self->file);
}

method _build_identifier {
  return $self->_raw->{config}{identifier};
}

method _build_kref {
  return $self->_raw->{config}{'$kref'};
}

method _build_vref {
  return $self->_raw->{config}{'$vref'} ? $self->_raw->{config}{'$vref'} : undef ;
}

method _build_name {
  return $self->_raw->{config}{name};
}

method _build_license {
  return $self->_raw->{config}{license} ? $self->_raw->{config}{license} : "unknown";
}

method _build_staging {
  return $self->_raw->{config}{'x_netkan_staging'} ? $self->_raw->{config}{'x_netkan_staging'} : 0 ;
}

method _build_staging_reason {
  return $self->_raw->{config}{'x_netkan_staging_reason'};
}

=method licenses

  $ckan->licenses();

Returns the license field as an array. Because unless there is
multiple values it won't be.

=cut

# Sometimes we always want an array.
method licenses {
  my @licenses = reftype \$self->license ne "SCALAR" ? @{$self->license} : $self->license;
  return \@licenses;
}

1;
