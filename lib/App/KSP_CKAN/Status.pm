package App::KSP_CKAN::Status;

use v5.010;
use strict;
use warnings;
use autodie;
use Method::Signatures 20140224;
use Carp qw( croak );
use IO::LockedFile;
use File::Slurper qw(read_text write_text);
use Try::Tiny;
use JSON;
use File::Path qw(mkpath);
use App::KSP_CKAN::Status::NetKAN;
use Moo;
use MooX::HandlesVia;
use namespace::clean;

# ABSTRACT: NetKAN Status Tracker

# VERSION: Generated by DZP::OurPkg:Version

=head1 SYNOPSIS

  use App::KSP_CKAN::Status;

  my $status = App::KSP_CKAN::Status->new(
    config => $config,
  );

=head1 DESCRIPTION

Status object for tracking status of at least initially, NetKAN
indexing.

=cut

my $Ref = sub {
  croak("auth isn't a 'App::KSP_CKAN::Tools::Config' object!") unless $_[0]->DOES("App::KSP_CKAN::Tools::Config");
};

has 'config'        => ( is => 'ro', required => 1, isa => $Ref );
has 'status_file'   => ( is => 'ro', default => sub { "netkan.json" } );
has 'status_path'   => ( is => 'ro', lazy => 1, builder => 1 );
has '_status_file'  => ( is => 'ro', lazy => 1, builder => 1 );
has '_json'         => ( is => 'ro', lazy => 1, builder => 1 );

method _build__json {
  return JSON->new->allow_blessed(1)->convert_blessed(1);
}

method _build_status_path {
  return $self->config->working."/status";
}

method _build__status_file {
  if ( ! -d $self->status_path ) {
    mkpath($self->status_path);
  }

  return $self->status_path."/".$self->status_file;
}

method _get_data() {
  my $raw;
  if (! -e $self->_status_file) {
    $raw = "{}";
  } else {
    $raw = read_text($self->_status_file);
  }

  my $data;
  try {
    $data = $self->_json->decode($raw);
  } catch {
    $self->logdie("JSON Status failed to parse");
  };

  return $data;
}

method _with_status($func) {
  # Open file with flock locking to manage concurrent access
  # This will block till it's our turn to be exclusive with the file
  my $fh = IO::LockedFile->new($self->_status_file, 'a+');

  # Load file contents and deserialize to JSON object
  my $data = $self->_json->decode(join('', <$fh>) || '{}');

  # Process the JSON object through function given in $func param
  my $new_data = $func->($data);

  # Clear the file so we can replace its contents
  $fh->truncate(0);

  # Jump back to beginning
  $fh->seek(0, 0);

  # Print new data to the file
  print $fh $self->_json->encode($new_data);

  # Lock will be released when $fh passes out of scope (now)
}

=method get_status

  my $netkan_status = $status->get_status( "BaconLabs" );

Will return a reference to the "BaconLabs" status object. Creating
it if necessary or loading it from the available data if it exists.

=cut

method get_status($name) {
  my $data = $self->_get_data();
  return $data->{$name}
    ? App::KSP_CKAN::Status::NetKAN->new($data->{$name})
    : App::KSP_CKAN::Status::NetKAN->new(name => $name);
}

=method prune_missing

  $status->prune_missing(@identifiers)

Removes from the status file any entries that aren't in the input list

=cut

# Remove the status entries that aren't in the input list
# This allows us to preserve ALL previous entries in later updates
method prune_missing(@identifiers) {
  $self->_with_status(sub {
    my $data = shift;
    my $new_data = {};
    # For simplicity, just copy across the ones that ARE in the input
    foreach my $id (@identifiers) {
      $new_data->{$id} = $data->{$id};
    }
    return $new_data;
  });
}

=method update_status

  $status->update_status($id, $status)

Set a module's status object to the given value

=cut

method update_status($id, $status) {
  $self->_with_status(sub {
    my $data = shift;
    $data->{$id} = $status;
    return $data;
  });
}

1;
